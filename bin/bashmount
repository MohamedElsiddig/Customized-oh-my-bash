#!/bin/bash

## Official repository https://github.com/jamielinux/bashmount.git


#		    GNU GENERAL PUBLIC LICENSE
#		       Version 2, June 1991

# Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
# Everyone is permitted to copy and distribute verbatim copies
# of this license document, but changing it is not allowed.

#			    Preamble

#  The licenses for most software are designed to take away your
#freedom to share and change it.  By contrast, the GNU General Public
#License is intended to guarantee your freedom to share and change free
#software--to make sure the software is free for all its users.  This
#General Public License applies to most of the Free Software
#Foundation's software and to any other program whose authors commit to
#using it.  (Some other Free Software Foundation software is covered by
#the GNU Lesser General Public License instead.)  You can apply it to
#your programs, too.

#  When we speak of free software, we are referring to freedom, not
#price.  Our General Public Licenses are designed to make sure that you
#have the freedom to distribute copies of free software (and charge for
#this service if you wish), that you receive source code or can get it
#if you want it, that you can change the software or use pieces of it
#in new free programs; and that you know you can do these things.

#  To protect your rights, we need to make restrictions that forbid
#anyone to deny you these rights or to ask you to surrender the rights.
#These restrictions translate to certain responsibilities for you if you
#distribute copies of the software, or if you modify it.

#  For example, if you distribute copies of such a program, whether
#gratis or for a fee, you must give the recipients all the rights that
#you have.  You must make sure that they, too, receive or can get the
#source code.  And you must show them these terms so they know their
#rights.

#  We protect your rights with two steps: (1) copyright the software, and
#(2) offer you this license which gives you legal permission to copy,
#distribute and/or modify the software.

#  Also, for each author's protection and ours, we want to make certain
#that everyone understands that there is no warranty for this free
#software.  If the software is modified by someone else and passed on, we
#want its recipients to know that what they have is not the original, so
#that any problems introduced by others will not reflect on the original
#authors' reputations.

#  Finally, any free program is threatened constantly by software
#patents.  We wish to avoid the danger that redistributors of a free
#program will individually obtain patent licenses, in effect making the
#program proprietary.  To prevent this, we have made it clear that any
#patent must be licensed for everyone's free use or not licensed at all.

#  The precise terms and conditions for copying, distribution and
#modification follow.

#		    GNU GENERAL PUBLIC LICENSE
#   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

#  0. This License applies to any program or other work which contains
#a notice placed by the copyright holder saying it may be distributed
#under the terms of this General Public License.  The "Program", below,
#refers to any such program or work, and a "work based on the Program"
#means either the Program or any derivative work under copyright law:
#that is to say, a work containing the Program or a portion of it,
#either verbatim or with modifications and/or translated into another
#language.  (Hereinafter, translation is included without limitation in
#the term "modification".)  Each licensee is addressed as "you".

#Activities other than copying, distribution and modification are not
#covered by this License; they are outside its scope.  The act of
#running the Program is not restricted, and the output from the Program
#is covered only if its contents constitute a work based on the
#Program (independent of having been made by running the Program).
#Whether that is true depends on what the Program does.

#  1. You may copy and distribute verbatim copies of the Program's
#source code as you receive it, in any medium, provided that you
#conspicuously and appropriately publish on each copy an appropriate
#copyright notice and disclaimer of warranty; keep intact all the
#notices that refer to this License and to the absence of any warranty;
#and give any other recipients of the Program a copy of this License
#along with the Program.

#You may charge a fee for the physical act of transferring a copy, and
#you may at your option offer warranty protection in exchange for a fee.

#  2. You may modify your copy or copies of the Program or any portion
#of it, thus forming a work based on the Program, and copy and
#distribute such modifications or work under the terms of Section 1
#above, provided that you also meet all of these conditions:

#    a) You must cause the modified files to carry prominent notices
#    stating that you changed the files and the date of any change.

#    b) You must cause any work that you distribute or publish, that in
#    whole or in part contains or is derived from the Program or any
#    part thereof, to be licensed as a whole at no charge to all third
#    parties under the terms of this License.

#    c) If the modified program normally reads commands interactively
#    when run, you must cause it, when started running for such
#    interactive use in the most ordinary way, to print or display an
#    announcement including an appropriate copyright notice and a
#    notice that there is no warranty (or else, saying that you provide
#    a warranty) and that users may redistribute the program under
#    these conditions, and telling the user how to view a copy of this
#    License.  (Exception: if the Program itself is interactive but
#    does not normally print such an announcement, your work based on
#    the Program is not required to print an announcement.)

#These requirements apply to the modified work as a whole.  If
#identifiable sections of that work are not derived from the Program,
#and can be reasonably considered independent and separate works in
#themselves, then this License, and its terms, do not apply to those
#sections when you distribute them as separate works.  But when you
#distribute the same sections as part of a whole which is a work based
#on the Program, the distribution of the whole must be on the terms of
#this License, whose permissions for other licensees extend to the
#entire whole, and thus to each and every part regardless of who wrote it.

#Thus, it is not the intent of this section to claim rights or contest
#your rights to work written entirely by you; rather, the intent is to
#exercise the right to control the distribution of derivative or
#collective works based on the Program.

#In addition, mere aggregation of another work not based on the Program
#with the Program (or with a work based on the Program) on a volume of
#a storage or distribution medium does not bring the other work under
#the scope of this License.

#  3. You may copy and distribute the Program (or a work based on it,
#under Section 2) in object code or executable form under the terms of
#Sections 1 and 2 above provided that you also do one of the following:

#    a) Accompany it with the complete corresponding machine-readable
#    source code, which must be distributed under the terms of Sections
#    1 and 2 above on a medium customarily used for software interchange; or,

#    b) Accompany it with a written offer, valid for at least three
#    years, to give any third party, for a charge no more than your
#    cost of physically performing source distribution, a complete
#    machine-readable copy of the corresponding source code, to be
#    distributed under the terms of Sections 1 and 2 above on a medium
#    customarily used for software interchange; or,

#    c) Accompany it with the information you received as to the offer
#    to distribute corresponding source code.  (This alternative is
#    allowed only for noncommercial distribution and only if you
#    received the program in object code or executable form with such
#    an offer, in accord with Subsection b above.)

#The source code for a work means the preferred form of the work for
#making modifications to it.  For an executable work, complete source
#code means all the source code for all modules it contains, plus any
#associated interface definition files, plus the scripts used to
#control compilation and installation of the executable.  However, as a
#special exception, the source code distributed need not include
#anything that is normally distributed (in either source or binary
#form) with the major components (compiler, kernel, and so on) of the
#operating system on which the executable runs, unless that component
#itself accompanies the executable.

#If distribution of executable or object code is made by offering
#access to copy from a designated place, then offering equivalent
#access to copy the source code from the same place counts as
#distribution of the source code, even though third parties are not
#compelled to copy the source along with the object code.

#  4. You may not copy, modify, sublicense, or distribute the Program
#except as expressly provided under this License.  Any attempt
#otherwise to copy, modify, sublicense or distribute the Program is
#void, and will automatically terminate your rights under this License.
#However, parties who have received copies, or rights, from you under
#this License will not have their licenses terminated so long as such
#parties remain in full compliance.

#  5. You are not required to accept this License, since you have not
#signed it.  However, nothing else grants you permission to modify or
#distribute the Program or its derivative works.  These actions are
#prohibited by law if you do not accept this License.  Therefore, by
#modifying or distributing the Program (or any work based on the
#Program), you indicate your acceptance of this License to do so, and
#all its terms and conditions for copying, distributing or modifying
#the Program or works based on it.

#  6. Each time you redistribute the Program (or any work based on the
#Program), the recipient automatically receives a license from the
#original licensor to copy, distribute or modify the Program subject to
#these terms and conditions.  You may not impose any further
#restrictions on the recipients' exercise of the rights granted herein.
#You are not responsible for enforcing compliance by third parties to
#this License.

#  7. If, as a consequence of a court judgment or allegation of patent
#infringement or for any other reason (not limited to patent issues),
#conditions are imposed on you (whether by court order, agreement or
#otherwise) that contradict the conditions of this License, they do not
#excuse you from the conditions of this License.  If you cannot
#distribute so as to satisfy simultaneously your obligations under this
#License and any other pertinent obligations, then as a consequence you
#may not distribute the Program at all.  For example, if a patent
#license would not permit royalty-free redistribution of the Program by
#all those who receive copies directly or indirectly through you, then
#the only way you could satisfy both it and this License would be to
#refrain entirely from distribution of the Program.

#If any portion of this section is held invalid or unenforceable under
#any particular circumstance, the balance of the section is intended to
#apply and the section as a whole is intended to apply in other
#circumstances.

#It is not the purpose of this section to induce you to infringe any
#patents or other property right claims or to contest validity of any
#such claims; this section has the sole purpose of protecting the
#integrity of the free software distribution system, which is
#implemented by public license practices.  Many people have made
#generous contributions to the wide range of software distributed
#through that system in reliance on consistent application of that
#system; it is up to the author/donor to decide if he or she is willing
#to distribute software through any other system and a licensee cannot
#impose that choice.

#This section is intended to make thoroughly clear what is believed to
#be a consequence of the rest of this License.

#  8. If the distribution and/or use of the Program is restricted in
#certain countries either by patents or by copyrighted interfaces, the
#original copyright holder who places the Program under this License
#may add an explicit geographical distribution limitation excluding
#those countries, so that distribution is permitted only in or among
#countries not thus excluded.  In such case, this License incorporates
#the limitation as if written in the body of this License.

#  9. The Free Software Foundation may publish revised and/or new versions
#of the General Public License from time to time.  Such new versions will
#be similar in spirit to the present version, but may differ in detail to
#address new problems or concerns.

#Each version is given a distinguishing version number.  If the Program
#specifies a version number of this License which applies to it and "any
#later version", you have the option of following the terms and conditions
#either of that version or of any later version published by the Free
#Software Foundation.  If the Program does not specify a version number of
#this License, you may choose any version ever published by the Free Software
#Foundation.

#  10. If you wish to incorporate parts of the Program into other free
#programs whose distribution conditions are different, write to the author
#to ask for permission.  For software which is copyrighted by the Free
#Software Foundation, write to the Free Software Foundation; we sometimes
#make exceptions for this.  Our decision will be guided by the two goals
#of preserving the free status of all derivatives of our free software and
#of promoting the sharing and reuse of software generally.

#			    NO WARRANTY

#  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
#FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
#OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
#PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
#OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
#TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
#PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
#REPAIR OR CORRECTION.

#  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
#WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
#REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
#INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
#OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
#TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
#YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
#PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
#POSSIBILITY OF SUCH DAMAGES.

#		     END OF TERMS AND CONDITIONS

#	    How to Apply These Terms to Your New Programs

#  If you develop a new program, and you want it to be of the greatest
#possible use to the public, the best way to achieve this is to make it
#free software which everyone can redistribute and change under these terms.

#  To do so, attach the following notices to the program.  It is safest
#to attach them to the start of each source file to most effectively
#convey the exclusion of warranty; and each file should have at least
#the "copyright" line and a pointer to where the full notice is found.

#    <one line to give the program's name and a brief idea of what it does.>
#    Copyright (C) <year>  <name of author>

#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.

#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.

#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

#Also add information on how to contact you by electronic and paper mail.

#If the program is interactive, make it output a short notice like this
#when it starts in an interactive mode:

#    Gnomovision version 69, Copyright (C) year name of author
#    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
#    This is free software, and you are welcome to redistribute it
#    under certain conditions; type `show c' for details.

#The hypothetical commands `show w' and `show c' should show the appropriate
#parts of the General Public License.  Of course, the commands you use may
#be called something other than `show w' and `show c'; they could even be
#mouse-clicks or menu items--whatever suits your program.

#You should also get your employer (if you work as a programmer) or your
#school, if any, to sign a "copyright disclaimer" for the program, if
#necessary.  Here is a sample; alter the names:

#  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
#  `Gnomovision' (which makes passes at compilers) written by James Hacker.

#  <signature of Ty Coon>, 1 April 1989
#  Ty Coon, President of Vice

#This General Public License does not permit incorporating your program into
#proprietary programs.  If your program is a subroutine library, you may
#consider it more useful to permit linking proprietary applications with the
#library.  If this is what you want to do, use the GNU Lesser General
#Public License instead of this License.


#=============================================================================#
#        FILE: bashmount                                                      #
#     VERSION: 3.2.0                                                          #
# DESCRIPTION: bashmount is a menu-driven bash script that can use different  #
#              backends to easily mount, unmount or eject removable devices   #
#              without dependencies on udisks or any GUI. An extensive        #
#              configuration file allows many aspects of the script to be     #
#              modified and custom commands to be run on devices.             #
#     LICENSE: GPLv2                                                          #
#     AUTHORS: Jamie Nguyen <j@jamielinux.com>                                #
#              Lukas B.                                                       #
#=============================================================================#

# Copyright (C) 2013-2014 Jamie Nguyen <j@jamielinux.com>
# Copyright (C) 2014 Lukas B.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License v2 as published by the
# Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA

declare -r VERSION='3.2.0'

if (( $# > 0 )); then
    if [[ "${1}" = '-V' || "${1}" = '--version' ]]; then
        cat << EOF
bashmount ${VERSION}
Copyright (C) 2013-2014 Jamie Nguyen <j@jamielinux.com>
Copyright (C) 2014 Lukas B.
License GPLv2: GNU GPL version 2 <http://www.gnu.org/licenses/gpl-2.0.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Jamie Nguyen and Lukas B.
EOF
        exit 0
    else
        printf '%s\n' 'bashmount: invalid option.'
        exit 64
    fi
fi

#-------------------------------------#
#           CONFIGURATION             #
#-------------------------------------#
# {{{
# Make sure that user defined options will not interfere with grep.
unset GREP_OPTIONS

# Set defaults.
declare udisks='auto'
declare default_mount_options='--options nosuid,noexec,noatime'
declare -i show_internal=1
declare -i show_removable=1
declare -i show_optical=1
declare -i show_commands=1
declare -i show_full_device_names=0
declare -i colourize=1
declare -i custom4_show=0
declare -i custom5_show=0
declare -i custom6_show=0
declare -i run_post_mount=0
declare -i run_post_unmount=0
declare -a blacklist=()

mount_command() {
    if (( udisks == 0 )); then
        read -r -e -p 'Choose the mountpoint directory: ' dir
        while [[ ! -d "${dir}" ]] || findmnt "${dir}" >/dev/null 2>&1; do
            error 'No such directory, or mountpoint is already in use.'
            read -r -e -p 'Choose the mountpoint directory: ' dir
        done
        mount ${mount_options} "${1}" "${dir}"
    else
        udisksctl mount ${mount_options} --block-device "${1}"
    fi
}

unmount_command() {
    if (( udisks == 0 )); then
        umount "${1}"
    else
        udisksctl unmount --block-device "${1}"
    fi
}

filemanager() {
    cd "${1}" && "$SHELL"
    exit 0
}

post_mount() {
    error "No command specified in 'bashmount.conf'."
    return 1
}

post_unmount() {
    error "No command specified in 'bashmount.conf'."
    return 1
}

# Load configuration file.
declare CONFIGFILE=

if [[ -z "${XDG_CONFIG_HOME}" ]]; then
    CONFIGFILE="${HOME}/.config/bashmount/config"
else
    CONFIGFILE="${XDG_CONFIG_HOME}/bashmount/config"
fi

if [[ ! -f "${CONFIGFILE}" ]]; then
    CONFIGFILE='/etc/bashmount.conf'
fi

if [[ -f "${CONFIGFILE}" ]]; then
    if ! . "${CONFIGFILE}"; then
        printf '%s\n' 'bashmount: Failed to source configuration file.'
        exit 78
    fi
fi

if [[ "${udisks}" == "auto" ]]; then
    type -p udisksctl >/dev/null 2>&1 && udisks=1 || udisks=0
elif  (( udisks == 1 )); then
    if ! type -p udisksctl >/dev/null 2>&1; then
        printf '%s\n' "bashmount: 'udisksctl': command not found"
        exit 69
    fi
fi

if ! type -p lsblk >/dev/null 2>&1; then
    printf '%s\n' "bashmount: 'lsblk': command not found"
    exit 69
fi

declare mount_options="${default_mount_options}"
# }}}

#-------------------------------------#
#         GENERAL FUNCTIONS           #
#-------------------------------------#
# {{{
unset ALL_OFF BOLD BLUE GREEN RED
if (( colourize )); then
    if tput setaf 0 >/dev/null 2>&1; then
        ALL_OFF="$(tput sgr0)"
        BOLD="$(tput bold)"
        BLUE="${BOLD}$(tput setaf 4)"
        GREEN="${BOLD}$(tput setaf 2)"
        RED="${BOLD}$(tput setaf 1)"
    else
        ALL_OFF='\e[1;0m'
        BOLD='\e[1;1m'
        BLUE="${BOLD}\e[1;34m"
        GREEN="${BOLD}\e[1;32m"
        RED="${BOLD}\e[1;31m"
    fi
    readonly ALL_OFF BOLD BLUE GREEN RED
fi

msg() {
    printf '%s\n' "${GREEN}==>${ALL_OFF}${BOLD} ${@}${ALL_OFF}" >&2
}

error() {
    printf '%s\n' "${RED}==>${ALL_OFF}${BOLD} ERROR: ${@}${ALL_OFF}" >&2
}

print_commands() {
    print_separator_commands
    printf '%s' "${BLUE}e${ALL_OFF}: eject   ${BLUE}i${ALL_OFF}: info"
    printf '%s' "   ${BLUE}m${ALL_OFF}: mount   ${BLUE}o${ALL_OFF}: open"
    printf '%s\n\n' "   ${BLUE}u${ALL_OFF}: unmount"
    printf '%s' "${BLUE}a${ALL_OFF}: unmount all"
    printf '%s' "   ${BLUE}r${ALL_OFF}: refresh"
    printf '%s\n\n' "   ${BLUE}q${ALL_OFF}: quit   ${BLUE}?${ALL_OFF}: help"
}

print_submenu_commands() {
    print_separator_commands
    printf '%s' "${BLUE}e${ALL_OFF}: eject   ${BLUE}i${ALL_OFF}: info"
    if info_mounted "${devname}"; then
        printf '%s' "   ${BLUE}u${ALL_OFF}: unmount"
    else
        printf '%s' "   ${BLUE}m${ALL_OFF}: mount"
    fi
    printf '%s\n\n' "   ${BLUE}o${ALL_OFF}: open"
    printf '%s' "${BLUE}b${ALL_OFF}: back   ${BLUE}r${ALL_OFF}: refresh"
    printf '%s\n' "   ${BLUE}q${ALL_OFF}: quit   ${BLUE}?${ALL_OFF}: help"

    printf '\n'
    printf '%s' "${BLUE}1${ALL_OFF}: read-only"
    printf '%s' "   ${BLUE}2${ALL_OFF}: luksOpen"
    printf '%s' "   ${BLUE}3${ALL_OFF}: luksClose"
    printf '\n'

    if (( custom4_show )) || (( custom5_show )) || (( custom6_show )); then
        printf '\n'
    fi

    if (( custom4_show )) && [[ -n "${custom4_desc}" ]]; then
        printf '%s' "${BLUE}4${ALL_OFF}: ${custom4_desc}"
    fi

    if (( custom5_show )) && [[ -n "${custom5_desc}" ]]; then
        printf '%s' "   ${BLUE}5${ALL_OFF}: ${custom5_desc}"
    fi

    if (( custom6_show )) && [[ -n "${custom6_desc}" ]]; then
        printf '%s' "   ${BLUE}6${ALL_OFF}: ${custom6_desc}"
    fi

    if (( custom4_show )) || (( custom5_show )) || (( custom6_show )); then
        printf '\n'
    fi
}

enter_to_continue() {
    printf '\n'
    read -r -e -p "Press [${BLUE}enter${ALL_OFF}] to continue: " null
}

invalid_command() {
    printf '\n'
    error 'Invalid command. See the help menu.'
    enter_to_continue
}

print_separator() {
    printf '%s\n\n' '====================================================='
}

print_separator_commands() {
    printf '%s\n\n' '===================== COMMANDS ======================'
}

print_separator_device() {
    printf '%s\n\n' '==================== DEVICE MENU ===================='
}

print_separator_optical() {
    printf '%s\n\n' '=================== OPTICAL MEDIA ==================='
}

print_separator_removable() {
    printf '%s\n\n' '================== REMOVABLE MEDIA =================='
}

print_separator_internal() {
    printf '%s\n\n' '================== INTERNAL MEDIA ==================='
}

print_help() {
    clear
    print_commands
    print_separator
    printf '%s' "${GREEN}==>${ALL_OFF} "
    printf '%s' "${BOLD}To mount the first device, enter ${ALL_OFF}"
    printf '%s' "${BLUE}1m${ALL_OFF}"
    printf '%s\n\n' "${BOLD}.${ALL_OFF}"
    printf '%s' "${GREEN}==>${ALL_OFF} "
    printf '%s\n\n' "${BOLD}To open the mountpath directory of the first${ALL_OFF}"
    printf '%s' "${BOLD}    device (mounting if required), enter "
    printf '%s' "${BLUE}1o${ALL_OFF}"
    printf '%s\n\n' "${BOLD}.${ALL_OFF}"
    printf '%s' "${GREEN}==>${ALL_OFF} "
    printf '%s' "${BOLD}To view a device sub-menu, "
    printf '%s\n\n' "just enter the number.${ALL_OFF}"
    printf '%s' "${GREEN}==>${ALL_OFF} "
    printf '%s' "${BLUE}a${ALL_OFF}"
    printf '%s' "${BOLD}, "
    printf '%s' "${BLUE}r${ALL_OFF}"
    printf '%s' "${BOLD}, "
    printf '%s' "${BLUE}q${ALL_OFF} "
    printf '%s' "${BOLD}and "
    printf '%s' "${BLUE}?${ALL_OFF} "
    printf '%s\n\n' "${BOLD}do not require a number.${ALL_OFF}"
    print_separator
    enter_to_continue
}

print_help_sub() {
    clear
    print_submenu_commands
    printf '\n'
    print_separator
    printf '%s' "${GREEN}==>${ALL_OFF} "
    printf '%s\n\n' "${BOLD}To perform a command, enter a character.${ALL_OFF}"
    printf '%s' "${GREEN}==>${ALL_OFF} "
    printf '%s' "${BOLD}For example, to mount this device, enter ${ALL_OFF}"
    printf '%s' "${BLUE}m${ALL_OFF}"
    printf '%s\n\n' "${BOLD}.${ALL_OFF}"
    print_separator
    enter_to_continue
}

print_device_name() {
    # The padding between device location and device label.
    local -i padding=22
    # For device names that are too long, this defines how many characters from
    # the end of the string we will show.
    local -i post_length=6

    info_label="$(info_fslabel "${devname}")"
    if [[ -z "${info_label}" ]]; then
        if [[ "${1}" == 'optical' ]]; then
            info_label="$(lsblk -dno MODEL "${devname}")"
        else
            info_label="$(info_partlabel "${devname}")"
        fi
        [[ -z "${info_label}" ]] && info_label='No label'
    fi

    listed[device_number]="${devname}"
    (( device_number++ ))

    printf '%s' " ${BLUE}${device_number})${ALL_OFF}"
    devnameshort="${devname##*/}"

    if (( !show_full_device_names )) && (( ${#devnameshort} > padding )); then
        pre_length=$(( padding - post_length - 3 ))
        devnamepre="${devnameshort:0:pre_length}"
        devnamepost="${devnameshort:${#devnameshort}-post_length}"
        devnameshort="${devnamepre}...${devnamepost}"
    fi

    printf '%s' " ${devnameshort}:"

    # Add padding between device location and device label.
    devname_length="${#devnameshort}"
    for (( i=padding ; i>devname_length ; i-- )); do
        printf '%s' " "
    done

    printf '%s' " ${info_label}"
    if info_mounted "${devname}"; then
        printf '%s' " ${GREEN}[mounted]${ALL_OFF}"
        mounted[${#mounted[*]}]="${devname}"
    fi
    printf '\n'
}

# }}}

#-------------------------------------#
#       INFORMATION RETRIEVAL         #
#-------------------------------------#
# {{{
# Returns 0 if the device is registered as removable device in the kernel,
# otherwise it returns 1.
info_removable() {
    [[ "$(lsblk -drno RM "${1}")" == '1' ]]
}

# Prints the device type, for example partition or disk.
info_type() {
    lsblk -drno TYPE "${1}"
}

# Prints the filesystem label, if present.
info_fslabel() {
    lsblk -drno LABEL "${1}"
}

# Prints the partition label, if present.
info_partlabel() {
    lsblk -drno PARTLABEL "${1}"
}

# Prints the mountpath, if mounted.
info_mountpath() {
    findmnt -no TARGET "${1}"
}

# Returns 0 if the device is mounted, 1 otherwise.
info_mounted() {
    findmnt -no TARGET "${1}" >/dev/null 2>&1
}

# Prints the filesystem type.
info_fstype() {
    lsblk -drno FSTYPE "${1}"
}

# Prints the device size.
info_size() {
    lsblk -drno SIZE "${1}"
}
# }}}

#-------------------------------------#
#        DEVICE MANIPULATION          #
#-------------------------------------#
# {{{
check_device() {
    if [[ ! -b "${1}" ]]; then
        printf '\n'
        error "${1} is no longer available."
        enter_to_continue
        return 1
    fi
    return 0
}

action_eject() {
    check_device "${1}" || return 1
    info_mounted "${1}" && action_unmount "${1}"
    if ! info_mounted "${1}"; then
        printf '\n'
        msg "Ejecting ${1} ..."
        printf '\n'
        eject "${1}"
        # Give the device some time to eject. If we don't then sometimes the ejected
        # device will still be present when returning to the main menu.
        enter_to_continue
        sleep 2
    fi
}

action_info() {
    check_device "${1}" || return 1
    lsblk -o NAME,FSTYPE,MOUNTPOINT,SIZE "${1}" | less
}

action_mount() {
    check_device "${1}" || return 1
    printf '\n'
    if info_mounted "${1}"; then
        error "${1} is already mounted."
    else
        msg "Mounting ${1} ..."
        if mount_command "${1}"; then
            msg "${1} mounted succesfullly."
            (( run_post_mount )) && post_mount "${1}"
        else
            printf '\n'
            error "${1} could not be mounted."
        fi
    fi
    enter_to_continue
}

action_open() {
    if ! info_mounted "${1}"; then
        printf '\n'
        msg "Mounting ${1} ..."
        if mount_command "${1}"; then
            msg "${1} mounted succesfullly."
            (( run_post_mount )) && post_mount "${1}"
        else
            printf '\n'
            error "${1} could not be mounted."
            enter_to_continue
            return 1
        fi
    fi
    printf '\n'
    msg "Opening ${1} ..."
    printf '\n'
    filemanager "$(info_mountpath "${1}")"
    enter_to_continue
}

action_unmount() {
    printf '\n'
    if info_mounted "${1}"; then
        msg "Unmounting ${1} ..."
        printf '\n'
        if unmount_command "${1}"; then
            msg "${1} unmounted successfully."
            (( run_post_unmount )) && post_unmount "${1}"
        else
            printf '\n'
            error "${1} could not be unmounted."
        fi
    else
        error "${1} is not mounted."
    fi
    enter_to_continue
}
# }}}

#-------------------------------------#
#           MENU FUNCTIONS            #
#-------------------------------------#
# {{{
list_devices() {
    local -a all=() removable=() internal=() optical=()
    # The array "all" contains the sorted list of devices returned by lsblk.
    all=( $(lsblk -plno NAME) )
    # The array "listed" contains all devices that are shown to the user.
    listed=()
    # The array "mounted" contains all devices that are listed and mounted.
    mounted=()
    # "device_number" is the total number of devices listed and equals ${#listed[*]}.
    device_number=0

    for devname in ${all[@]}; do
        local info_type=
        # Hide blacklisted devices.
        for string in ${blacklist[@]}; do
            lsblk -dPno NAME,TYPE,FSTYPE,LABEL,MOUNTPOINT,PARTLABEL "${devname}" \
                | grep -E "${string}" >/dev/null 2>&1
            (( $? )) || continue 2
        done
        info_type=$(info_type "${devname}")
        # Sort devices into arrays removable, internal, and optical.
        if [[ "${info_type}" == 'part' || "${info_type}" == 'crypt' ]]; then
            if info_removable "${devname}"; then
                removable[${#removable[*]}]="${devname}"
            else
                internal[${#internal[*]}]="${devname}"
            fi
        # Normally we don't want to see a 'disk', but if it has no partitions
        # (eg, internal storage on some portable media devices) then it should
        # be visible.
        elif [[ "${info_type}" == 'disk' ]]; then
            [[ "${all[@]}" =~ ${devname}1 ]] && continue
            if info_removable "${devname}"; then
                removable[${#removable[*]}]="${devname}"
            else
                internal[${#internal[*]}]="${devname}"
            fi
        elif [[ "${info_type}" == 'rom' ]]; then
            optical[${#optical[*]}]="${devname}"
        else
            continue
        fi
    done
    # Print output.
    # List internal media.
    if (( show_internal )) && (( ${#internal[*]} )); then
        print_separator_internal
        for devname in ${internal[@]}; do
            print_device_name
        done
        printf '\n'
    fi
    # List removable media.
    if (( show_removable )) && (( ${#removable[*]} )); then
        print_separator_removable
        for devname in ${removable[@]}; do
            print_device_name
        done
        printf '\n'
    fi
    # List optical media.
    if (( show_optical )) && (( ${#optical[*]} )); then
        print_separator_optical
        for devname in ${optical[@]}; do
            print_device_name optical
        done
        printf '\n'
    fi
    (( device_number )) || printf '%s\n' 'No devices.'
}

submenu() {
    check_device "${devname}" || return 1
    local info_label= info_fstype= info_size=
    info_label="$(info_fslabel "${devname}")"
    if [[ -z "${info_label}" ]]; then
        info_label="$(info_partlabel "${devname}")"
        if [[ -z "${info_label}" ]]; then
            info_label='-'
        fi
    fi
    info_fstype="$(info_fstype "${devname}")"
    info_size="$(info_size "${devname}")"
    clear
    print_separator_device
    printf '%s\n' "device    : ${devname}"
    printf '%s\n' "label     : ${info_label}"
    printf '%s' 'mounted   : '
    if info_mounted "${devname}"; then
        printf '%s\n' "${GREEN}yes${ALL_OFF}"
        printf '%s\n' "mountpath : $(info_mountpath "${devname}")"
    else
        printf '%s\n' "${RED}no${ALL_OFF}"
    fi
    printf '%s\n' "fstype    : ${info_fstype}"
    printf '%s\n' "size      : ${info_size}"
    if (( show_commands )); then
        printf '\n'
        print_submenu_commands
    fi
    printf '\n'
    print_separator
    read -r -e -p 'Command: ' action
    case "${action}" in
        'e') action_eject "${devname}";;
        'i') action_info "${devname}";;
        'm') action_mount "${devname}";;
        'o') action_open "${devname}";;
        'u') action_unmount "${devname}";;
        'b') return 1;;
        'r') return 0;;
        'q') exit;;
        '?')
            print_help_sub
            return 0;;
        '1')
            printf '\n'
            msg 'Mounting read-only ...'
            printf '\n'
            mount_options="${default_mount_options}"' --read-only'
            mount_command "${devname}"
            mount_options="${default_mount_options}"
            enter_to_continue
            return 0;;
        '2')
            printf '\n'
            msg 'Opening luks volume ...'
            printf '\n'
            if (( udisks == 0 )); then
                cryptsetup open --type luks -v "${devname}" "luks-${devname##*/}"
            else
                udisksctl unlock --block-device "${devname}"
            fi
            enter_to_continue
            return 0;;
        '3')
            printf '\n'
            msg 'Closing luks volume ...'
            printf '\n'
            if (( udisks == 0 )); then
                cryptsetup close --type luks "${devname}"
            else
                udisksctl lock --block-device "${devname}"
            fi
            enter_to_continue
            return 0;;
        '4')
            if (( custom4_show )); then
                printf '\n'
                msg "Running custom command ${custom4_desc} ..."
                printf '\n'
                custom4_command "${devname}"
                enter_to_continue
            else
                invalid_command
            fi
            return 0;;
        '5')
            if (( custom5_show )); then
                printf '\n'
                msg "Running custom command ${custom5_desc} ..."
                printf '\n'
                custom5_command "${devname}"
                enter_to_continue
            else
                invalid_command
            fi
            return 0;;
        '6')
            if (( custom6_show )); then
                printf '\n'
                msg "Running custom command ${custom6_desc} ..."
                printf '\n'
                custom6_command "${devname}"
                enter_to_continue
            else
                invalid_command
            fi
            return 0;;
         *) invalid_command
            return 0;;
    esac
}

select_action() {
    local devname= letter=
    local -i number=
    print_separator
    read -r -e -p 'Command: ' action
    if [[ "${action}" =~ ^[1-9] ]]; then
        if [[ "${action}" =~ ^[1-9][0-9]*$ ]]; then
            number="$(( action - 1 ))"
            if (( number >= device_number )); then
                invalid_command
                return 1
            fi
            devname=${listed[number]}
            while :; do
                submenu || break
            done
        elif [[ "${action}" =~ ^[1-9][0-9]*[eimou]$ ]]; then
            number="$(( ${action%?} - 1 ))"
            letter="${action: -1}"
            if (( number >= device_number )); then
                invalid_command
                return 1
            fi
            devname="${listed[number]}"
            case "${letter}" in
                'e') action_eject "${devname}";;
                'i') action_info "${devname}";;
                'm') action_mount "${devname}";;
                'o') action_open "${devname}";;
                'u') action_unmount "${devname}";;
                 *)  return 1;;
            esac
            return 0
        else
            invalid_command
            return 1
        fi
    else
        case "${action}" in
            'a')
                printf '\n'
                if (( ! ${#mounted[*]} )); then
                    error 'No devices mounted.'
                    enter_to_continue
                    return 1
                fi
                read -r -e -p 'Unmount all devices [y/N]?: ' unmount
                if [[ "${unmount}" != 'y' ]] && [[ "${unmount}" != 'Y' ]]; then
                    return 0
                fi
                clear
                for devname in ${mounted[@]}; do
                    action_unmount "${devname}" || continue
                done
                enter_to_contine
                return 1;;
            'r'|"")
                return 0;;
            'q'|'b')
                exit 0;;
            '?')
                print_help
                return 0;;
            *)
                invalid_command
                return 1;;
        esac
    fi
}
# }}}

declare -i device_number=
declare -a mounted=()
declare -a listed=()

while true; do
    clear
    list_devices
    (( show_commands )) && print_commands
    select_action
done
